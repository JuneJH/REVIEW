# 网络相关问题

1. TCP/IP协议分层管理

    - 应用层    http，dns，ftp
    - 传输层    tcp/udp
    - 网络层    ip
    - 数据链路层
    - 物理层

2. 三次握手四次挥手机制及原因
    - TCP是面向连接的协议，因此需要先进行连接，就是通过三次握手进行连接。
    * 三次握手的过程
    1. 一开始客户端是出于关闭状态，服务端是监听状态，然后客户端发送一个SYN=1和序号给服务端
    2. 服务端接受到后，回复SYN和ACK字段。此时还可以确认服务端的收数据功能正常
    3. 客服端收到后，可以确认自己的收发功能正常。回复一个ACK，这一次也可以发送业务数据了。
    * 四次挥手的过程
    1. 当客户端发送一个FIN字段时表示自己的数据已经发送完成，需要关闭连接
    2. 服务端收到后，需要回复一个ACK确认消息
    3. 服务端确认自己也没有数据了，也发送一个FIN字段告诉客户端即将关闭连接
    4. 客户端收到后，不会立即关闭连接，而是进入等待状态，并发送一个ACK回复服务端，服务端收到后立即关闭连接

3. HTTP方法
    1. GET  请求的指定页面信息，并返回实体
    2. POST 
    3. PUT  
    4. HEAD 类似GET，只不过响应中没有具体内容，主要用于后去报头
    5. DELETE
    6. OPTIONS  允许客服端查看服务端性能。当使用CORS进行跨域时的非简单请求就会使用该方法
    7. TRACE
    8. CONNECT

4. GET和POST的区别
    * 他们本质上并没有什么区别，他们的底层都是tcp连接，因此在技术上都可以做一样的事，只不过浏览器给了我们前端一些限制，就让他们具有了区别
    * 首先从他们的业务参数的位置来说，一个是放在url地址栏中，一个是放在请求体中
    1. 因此get请求会限制长度，因为浏览的url地址栏的长度有限制，而post不存在
    2. get请求的编码格式有限制，
    3. get相对于post，安全性较低，主要是出现在地址栏上统一被偷窥或者误分享
    * 其他方面
    4. get请求是可以缓存以及利于分享的和历史记录的，如果是post请求则会重新提交表单
    5. get请求只发送一个数据包，而post需要发送两次数据包
    * 从语义上来说
    6. get是请求数据的，post使用来提交数据的，因此get不会影响到服务器的数据，请求多次都是一样的即幕等，post是不幕等

5. HTTP建立持久连接的意义
    * 长连接，即当一个请求完成后，可以继续使用该连接。在http1.1中默认长连接keep-alive
    * 短连接，当一个请求完成后，立即关闭该连接，在http1.0时默认短连接
        1. 短连接浪费资源，建立一个TCP连接需要三次握手，关闭一个连接需要四次挥手，就是7个数据包，如果只是发送一个简单的数据，就更加极为浪费
        2. 由于关闭连接后，客户端不会立即关闭，因此可能会堆积大量的等待关闭的TCP连接

6. HTTP报文的结构
    1. 请求报文
    - 请求行    请求方法-请求url-请求协议
    - 请求体    一些属性键值对
    - 空行
    - 请求体    请求所需要的参数等
    2. 响应报文
    - 响应行    协议-状态码-状态码描述
    - 响应体
    - 空行
    - 响应体

7. HTTP状态码
    1. 1XX  指示信息，表示数据已收到，请继续操作
    2. 2XX  成功
        - 200 一切正常，成功，强缓存也会返回该状态码
        - 204 Not Content 无内容，即服务端收到了，但是没有什么东西给客服端
    3. 3XX 重定向
        - 301 永久重定向，新的地址在locahost中
        - 302 临时重定向
        - 303 于302一致，只不过客户端将换用get方法请求
        - 307 同302，只不过不用修改请求方法
        - 304 协商缓存
    4. 4XX 客服端错误
        - 400 语法错误
        - 403 服务端收到请求，拒绝服务
        - 404 没有找到
        - 415 不支持媒体类型
    5. 5XX 服务端错误
        - 500 服务端发送不可预期的错误
        - 503 服务端当前不能处理该业务，可能过一段时间可以

8. Web服务器及其组成

9. HTTP报文首部
10. HTTP通用首部字段
11. HTTP请求首部字段、响应首部字段、实体首部字段
12. Cookie相关首部字段
    - name
    - path
    - value
    - expires/max-age
    - domain
    - secure
    - sameSite
    - httpOnly

13. HTTPS与HTTP区别及实现方式
    HTTPS是通过http传输数据但是通过TLS进行加密的

14. Cookie与Session
    - cookie是用来解决http的特性之一无状态的，它是存放再客户端的
    - session是存放再服务端的

15. 基于HTTP的功能追加协议（SPY、WebSocket、HTTP）

16. 常见的Web攻击分类
     - XSS
     - CSRF
     - SQL注入

17. TCP与UDP区别
    - TCP是面向连接的，每次连接时需要经历三次握手进行连接，断开连接时需要经历四次挥手断开连接
    - UDP是面向无连接的，只管发送，它的报文更短，它支持一对一，广播。适合应用再实时要求较高的场景

18. 存储机制localStorage、sessionStorage与Cookie存储技术
    - http协议是上下无关的协议，因此使用该协议不能监控其状态，于是出现了Cookie用来保存状态，它是一个字符串的键值对，他只能存放4k的内容，每次请求将跟随请求头发送至服务端，cookie也分为会话cookie，主要是通过设置expires和max-age来指定它的生命周期
    - webStorage是再html5提出来的，同样它满足同源共享，但是它可以存放更多的内容，根据浏览器的不同大概再5M~10M左右，他不会跟随http请求一同发送至服务器。
    * webStorage又分为localStorage和sessionStorage，他们主要不同在于生命周期，和数据共享上，sessionStorage是属于会话期的，它的数据只能当前页使用。

19. XSS攻击及防御
    - XSS cross site script 跨站脚本攻击。主要有反射性，通过诱导用户点击攻击者设计好的连接，然后利用用户获得的权限进行其他攻击。存储型，利用评论区或者可输入的地方，进行书写带有攻击的脚本，服务器保存该恶意脚本后，下次其他用户再次访问该网页时就会执行该脚本。修改DOM型，会利用输入的漏洞，就行修改dom结构，主要是添加一个连接。

    - 防御XSS攻击主要可以限制Cookie的访问权限，虽然这不是再防御XSS，这更像是再保护自己，可以通过httpOnly设置脚本不可访问cookie。
    - 不能信任用户的任何输入，对用户输入进行转译。
    - 输出转译
    - CSP 白名单

20. CSRF攻击及防御
    - CSRF 跨站请求伪装，利用获得用户的权限进行伪造请求对服务器发起攻击，攻击者诱导用户点击链接，获得用户权限，伪造请求给服务器。
    - 防御  可以通过设置cookie的sameSite来控制跨域不携带cookie，认证referer，添加token再请求头中，主要是利用页面的交互来确认不是伪造的请求