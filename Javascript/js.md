# 从问题开始
1. 原始值和引用值类型及区别
    - .1 + 0.2 !=0.3。null在通过typeof识别的时候，它的结果是Object。除了null和undefined没有包装类的，其余的都存在包装类，比如一个字符串可以通过点调用length，这不会报错而且能够正确返回长度就是js默认做了一个类处理，但是会立即销毁，所以即时你将length赋值为零同样无效。引用值就是对象，他存放的是指针，即地址。因为这个原因两个对象在比较的时候他将比较的是其地址，对象就会涉及到垃圾回收机制，在v8引擎中，采用分代式垃圾回收机制，其中主要分为新生代，老生代，大象区，map区等等，完成垃圾回收主要是新生代和老生代，在声明一个变量的时候，会将该变量放入新生代的from间，由于新生代是使用scavenge算法，这个算法是通过牺牲空间换取时间的一种算法，因此它除了from空间还存在一个to空间，在进行垃圾回收时，会遍历from空间，找出仍存活的对象并赋值给to空间，进行完成后，将from清空，并且to空间改为from空间，from空间改为to空间。在新生代的对象可以通过对象晋升进入到老生代，老生代主要是通过标记清理算法来进行垃圾回收，比如在全局下，通过全局对象进行遍历，能遍历到的就标记，在标记完成后，清除没有标记。这样下来就会产生许多的碎片空间，因此再执行标记整理，将存活对象向一端移动，然后进行整理。即时这样也会存在全停顿，因为再执行垃圾回收时，由于js是单线程，所以必然会导致js正常的程序逻辑处于等待，因此又推出增量标记清理，和延迟清理，这就有点类似于时间轮转调度的感觉。关于引用值还存在克隆问题，再进行引用值复制的时候，因为他存放的是指针，所以必然直接复制的是他的指针，因此就出现深浅克隆问题，

2. 判断数据类型typeof、instanceof、Object.prototype.toString.call()、constructor
    - 判断数据的基本类型可以使用typeof，typeof能够判断原始类型，但是null会判定为Object，能够判断函数，其余都会判断为Object。为了可以准确的判断对象类型，可以利用instanceof，它是基于原型链实现的，他会找到最近的一层原型，但是它存在不准的情况，因为可以通过Es6中的具名符号可以对其底层进行修改。还有就是不能判断原型值，因为原始值没有原型。除此之外可以通过Object.prototype.toString.call()实现对数据类型的判断，他将放回的是一个字符串，一个中括号，前者是object，后者就是真实的数据类型，但是我测试了，它的缺点可能就是不能够判断自定义数据类型，但是它可以识别js系统对象，比如date对象。最后还可以通过constructor，它是指向构造自己的函数的

3. 类数组与数组的区别与转换
    - 类数组是一个具有length和可以值为数值的对象，它不具有数组的方法，可以通过slice(),Array.from(),展开运算符等将类数组转化为数组

4. 数组的常见API
    - splice，slice，sort，Array.forEach,Array.some,Array.map....

5. bind、call、apply的区别
    - 他们三个都是用来该变函数指向的，call和apply他们都是立即执行，他们的不同之处在于传参方式不同，call的参数要一个一个的传，apply接受一个参数列表，bind是返回一个绑定的this的函数，而且无论后续再对该函数进行更改this操作，都只会认定最开始的，除非痛new操作符。我自己再实现这三个函数的时候都是基础this中谁调用的this就指向谁这条规则实现的

6. new的原理
    - 当对一个函数进行new操作时，再内部会制造出一个对象，并且将该对象的原型中constructor指向该构造函数，并且将this指向该对象，然后开始指向构造函数中的语句。最后隐式放回this，如果开发者自己返回一个对象，就不会再隐式放回。除此之外箭头函数不能当做构造函数，也就不能通过new执行，因为他没有this，argument，new.target。

7. 如何正确判断this？
    - 在非严格模式下的全局下指向全局对象。在严格模式下将指向undefined。
    - 谁调用的就指向谁。
    - 通过bind绑定函数的this不能再改变，除非new
    - new的this的权限是最高的

8. 闭包及其作用
    - 在MDN的定义下是，任何函数能够访问到自由变量的就是闭包
    - 但是在开发中一般是指一个函数能够访问到另外一个函数的作用域，比如将一个函数内部的函数保存在全局后者外部，这就将形成闭包，即使外部函数执行完毕后，它的执行上下文会销毁，但是它的子函数仍处于活跃状态，不会被垃圾回收，它的作用域链中包含了父函数的变量对象。
    防止变量污染，一些框架都是写在一个立即执行函数中的，然后利用闭包实现命名的独立
    做一些缓存，一些记忆函数，防抖，柯里化，动态规划都会利用闭包做一个缓存，用来保存之前的数据
    总之灵活使用闭包，会让代码看起来比较巧妙，但是闭包会造成内存泄漏，在垃圾回收时，得不到释放。

9. 原型和原型链
    - 原型是绝大部分函数都具有的一个属性，箭头函数没有原型，它是由该构造函数所生成的对象的公共集合
10. prototype与__proto__的关系与区别
11. 继承的实现方式及比较
12. 深拷贝与浅拷贝
13. 防抖和节流
14. 作用域和作用域链、执行期上下文
15. DOM常见的操作方式
16. Array.sort()方法与实现机制
17. Ajax的请求过程
18. JS的垃圾回收机制
19. JS中的String、Array和Math方法
20. addEventListener和onClick()的区别
21. new和Object.create的区别
22. DOM的location对象
23. 浏览器从输入URL到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程）
24. 跨域、同源策略及跨域实现方式和原理
25. 浏览器的回流（Reflow）和重绘（Repaints）
26. JavaScript中的arguments
27. EventLoop事件循环
28. 宏任务与微任务
29. BOM属性对象方法
30. 函数柯里化及其通用封装
31. JS的map()和reduce()方法
32. “==”和“===”的区别
33. setTimeout用作倒计时为何会产生误差？